# üìù √ñnce/Sonra Kod √ñrnekleri

Bu dok√ºman, refactoring √∂ncesi ve sonrasƒ± kod √∂rneklerini yan yana g√∂sterir.

---

## 1Ô∏è‚É£ Controller Layer

### ‚ùå √ñNCE

```java
@RestController
@RequestMapping("/")
@RequiredArgsConstructor
@Slf4j
public class UserController {

    private final UserService userService;

    @GetMapping("/{userId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ApiResponse<UserResponse>> getUser(@PathVariable UUID userId) {
        log.debug("Getting user: {}", userId);

        // üî¥ SecurityContext extraction - TEKRAR
        UUID tenantId = SecurityContextHolder.getCurrentTenantId();
        UserResponse user = userService.getUser(userId, tenantId);

        // üî¥ Response wrapping - TEKRAR
        return ResponseEntity.ok(ApiResponse.success(user));
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")  // üî¥ Magic string
    public ResponseEntity<ApiResponse<UUID>> createUser(@Valid @RequestBody CreateUserRequest request) {
        log.info("Creating user: {}", request.getEmail());

        // üî¥ SecurityContext extraction - TEKRAR
        UUID tenantId = SecurityContextHolder.getCurrentTenantId();
        String createdBy = SecurityContextHolder.getCurrentUserId();

        UUID userId = userService.createUser(request, tenantId, createdBy);

        // üî¥ Response wrapping - TEKRAR
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(userId, "User created successfully"));
    }
}
```

**Sorunlar:**

- SecurityContext extraction her method'da tekrar
- Response wrapping her method'da tekrar
- Magic string roller
- 181 satƒ±r (gereksiz tekrar)

### ‚úÖ SONRA

```java
@RestController
@RequestMapping("/")
@RequiredArgsConstructor
@Slf4j
public class UserController {

    private final UserService userService;

    @GetMapping("/{userId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ApiResponse<UserResponse>> getUser(
            @PathVariable UUID userId,
            @CurrentSecurityContext SecurityContext ctx) {  // ‚úÖ Clean injection

        log.debug("Getting user: {}", userId);
        UserResponse user = userService.getUser(userId, ctx.getTenantId());
        return ResponseEntity.ok(ApiResponse.success(user));
    }

    @PostMapping
    @AdminOnly  // ‚úÖ Custom annotation
    public ResponseEntity<ApiResponse<UUID>> createUser(
            @Valid @RequestBody CreateUserRequest request,
            @CurrentSecurityContext SecurityContext ctx) {

        log.info("Creating user: {}", request.getEmail());
        UUID userId = userService.createUser(request, ctx.getTenantId(), ctx.getUserId());

        return ResponseEntity.status(HttpStatus.CREATED)
            .body(ApiResponse.success(userId, "User created successfully"));
    }
}
```

**ƒ∞yile≈ütirmeler:**

- ‚úÖ SecurityContext clean injection
- ‚úÖ Kod tekrarƒ± yok
- ‚úÖ Custom annotation
- ‚úÖ 120 satƒ±r (-34%)

---

## 2Ô∏è‚É£ Service Layer

### ‚ùå √ñNCE

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class UserService {

    private final UserRepository userRepository;
    private final ContactServiceClient contactServiceClient;
    private final UserEventPublisher eventPublisher;

    @Transactional(readOnly = true)
    public UserResponse getUser(UUID userId, UUID tenantId) {
        log.debug("Getting user: {} for tenant: {}", userId, tenantId);

        // üî¥ Tekrar eden find logic
        User user = userRepository.findById(userId)
                .filter(u -> !u.isDeleted())
                .filter(u -> u.getTenantId().equals(tenantId))
                .orElseThrow(() -> new RuntimeException("User not found: " + userId));

        // üî¥ Mapping logic service i√ßinde
        return mapToResponse(user);
    }

    @Transactional
    public UUID createUser(CreateUserRequest request, UUID tenantId, String createdBy) {
        log.info("Creating user: {} for tenant: {}", request.getEmail(), tenantId);

        // üî¥ Entity creation service i√ßinde
        User user = User.builder()
                .id(UUID.randomUUID())
                .tenantId(tenantId)
                .firstName(request.getFirstName())
                .lastName(request.getLastName())
                .displayName(request.getDisplayName())
                .status(UserStatus.PENDING_VERIFICATION)
                .registrationType(RegistrationType.DIRECT_REGISTRATION)
                .role(request.getRole() != null ? request.getRole() : "USER")
                .preferences(request.getPreferences())
                .settings(request.getSettings())
                .createdBy(createdBy)
                .updatedBy(createdBy)
                .deleted(false)
                .version(0L)
                .build();

        user = userRepository.save(user);

        // üî¥ Event creation service i√ßinde
        UserCreatedEvent event = UserCreatedEvent.builder()
                .userId(user.getId())
                .tenantId(user.getTenantId().toString())
                .firstName(user.getFirstName())
                .lastName(user.getLastName())
                .email(request.getEmail())
                .status(user.getStatus().name())
                .registrationType(user.getRegistrationType().name())
                .timestamp(LocalDateTime.now())
                .build();

        eventPublisher.publishUserCreated(event);
        return user.getId();
    }

    @Transactional(readOnly = true)
    public List<UserResponse> listUsers(UUID tenantId) {
        log.debug("Listing users for tenant: {}", tenantId);

        List<User> users = userRepository.findByTenantId(tenantId);

        // üî¥ N+1 query problem - her user i√ßin Feign call
        return users.stream()
                .map(this::mapToResponse)
                .collect(Collectors.toList());
    }

    // üî¥ 65+ satƒ±r mapping logic
    private UserResponse mapToResponse(User user) {
        String email = null;
        String phone = null;

        try {
            ApiResponse<List<ContactDto>> response =
                contactServiceClient.getContactsByOwner(user.getId().toString());
            List<ContactDto> contacts = response != null && response.getData() != null
                ? response.getData() : null;

            if (contacts != null) {
                for (ContactDto contact : contacts) {
                    if ("EMAIL".equals(contact.getContactType()) && contact.isPrimary()) {
                        email = contact.getContactValue();
                    } else if ("PHONE".equals(contact.getContactType()) && contact.isPrimary()) {
                        phone = contact.getContactValue();
                    }
                }

                if (email == null) {
                    email = contacts.stream()
                            .filter(c -> "EMAIL".equals(c.getContactType()))
                            .findFirst()
                            .map(ContactDto::getContactValue)
                            .orElse(null);
                }

                if (phone == null) {
                    phone = contacts.stream()
                            .filter(c -> "PHONE".equals(c.getContactType()))
                            .findFirst()
                            .map(ContactDto::getContactValue)
                            .orElse(null);
                }
            }
        } catch (Exception e) {
            log.warn("Failed to fetch contacts for user {}: {}", user.getId(), e.getMessage());
        }

        return UserResponse.builder()
                .id(user.getId())
                .tenantId(user.getTenantId())
                .firstName(user.getFirstName())
                .lastName(user.getLastName())
                .displayName(user.getDisplayName())
                .email(email)
                .phone(phone)
                .status(user.getStatus() != null ? user.getStatus().name() : null)
                .registrationType(user.getRegistrationType() != null ? user.getRegistrationType().name() : null)
                .role(user.getRole())
                .lastLoginAt(user.getLastLoginAt())
                .lastLoginIp(user.getLastLoginIp())
                .preferences(user.getPreferences())
                .settings(user.getSettings())
                .createdAt(user.getCreatedAt())
                .updatedAt(user.getUpdatedAt())
                .createdBy(user.getCreatedBy())
                .updatedBy(user.getUpdatedBy())
                .version(user.getVersion())
                .build();
    }
}
```

**Sorunlar:**

- 370 satƒ±r (√ßok uzun)
- Mapping logic service i√ßinde (SRP ihlali)
- Entity creation service i√ßinde
- Event creation service i√ßinde
- N+1 query problem
- Tekrar eden find logic

### ‚úÖ SONRA

```java
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class UserService {

    private final UserRepository userRepository;
    private final UserMapper userMapper;
    private final UserEventPublisher eventPublisher;

    @Transactional(readOnly = true)
    public UserResponse getUser(UUID userId, UUID tenantId) {
        log.debug("Getting user: {} for tenant: {}", userId, tenantId);

        User user = userRepository.findActiveByIdAndTenantId(userId, tenantId)
            .orElseThrow(() -> new UserNotFoundException(userId));

        return userMapper.toResponse(user);
    }

    public UUID createUser(CreateUserRequest request, UUID tenantId, String createdBy) {
        log.info("Creating user: {} for tenant: {}", request.getEmail(), tenantId);

        User user = userMapper.toEntity(request, tenantId, createdBy);
        user = userRepository.save(user);

        eventPublisher.publishUserCreated(user);
        return user.getId();
    }

    @Transactional(readOnly = true)
    public List<UserResponse> listUsers(UUID tenantId) {
        log.debug("Listing users for tenant: {}", tenantId);

        List<User> users = userRepository.findAllActiveByTenantId(tenantId);
        return userMapper.toResponseList(users);  // Batch processing
    }

    public void updateUser(UUID userId, UpdateUserRequest request, UUID tenantId, String updatedBy) {
        log.info("Updating user: {} for tenant: {}", userId, tenantId);

        User user = userRepository.findActiveByIdAndTenantId(userId, tenantId)
            .orElseThrow(() -> new UserNotFoundException(userId));

        userMapper.updateEntity(user, request, updatedBy);
        userRepository.save(user);

        eventPublisher.publishUserUpdated(user);
    }
}
```

**ƒ∞yile≈ütirmeler:**

- ‚úÖ 150 satƒ±r (-59%)
- ‚úÖ Single Responsibility
- ‚úÖ Mapping logic ayrƒ±ldƒ± (UserMapper)
- ‚úÖ Clean code
- ‚úÖ Test edilebilir
- ‚úÖ Repository custom methods

---

## 3Ô∏è‚É£ Mapper Layer (YENƒ∞)

### ‚úÖ UserMapper.java

```java
@Component
@RequiredArgsConstructor
@Slf4j
public class UserMapper {

    private final ContactServiceClient contactClient;

    /**
     * Entity ‚Üí Response DTO
     */
    public UserResponse toResponse(User user) {
        ContactInfo contact = fetchContactInfo(user.getId());

        return UserResponse.builder()
            .id(user.getId())
            .tenantId(user.getTenantId())
            .firstName(user.getFirstName())
            .lastName(user.getLastName())
            .displayName(user.getDisplayName())
            .email(contact.getEmail())
            .phone(contact.getPhone())
            .status(user.getStatus() != null ? user.getStatus().name() : null)
            .registrationType(user.getRegistrationType() != null ? user.getRegistrationType().name() : null)
            .role(user.getRole())
            .lastLoginAt(user.getLastLoginAt())
            .lastLoginIp(user.getLastLoginIp())
            .preferences(user.getPreferences())
            .settings(user.getSettings())
            .createdAt(user.getCreatedAt())
            .updatedAt(user.getUpdatedAt())
            .createdBy(user.getCreatedBy())
            .updatedBy(user.getUpdatedBy())
            .version(user.getVersion())
            .build();
    }

    /**
     * Entity List ‚Üí Response DTO List (with batch optimization)
     */
    public List<UserResponse> toResponseList(List<User> users) {
        // TODO: Batch fetch contacts (Sprint 3)
        // For now, individual calls
        return users.stream()
            .map(this::toResponse)
            .collect(Collectors.toList());
    }

    /**
     * Request DTO ‚Üí Entity
     */
    public User toEntity(CreateUserRequest request, UUID tenantId, String createdBy) {
        return User.builder()
            .id(UUID.randomUUID())
            .tenantId(tenantId)
            .firstName(request.getFirstName())
            .lastName(request.getLastName())
            .displayName(request.getDisplayName() != null
                ? request.getDisplayName()
                : request.getFirstName() + " " + request.getLastName())
            .status(UserStatus.PENDING_VERIFICATION)
            .registrationType(RegistrationType.DIRECT_REGISTRATION)
            .role(request.getRole() != null ? request.getRole() : "USER")
            .preferences(request.getPreferences())
            .settings(request.getSettings())
            .createdBy(createdBy)
            .updatedBy(createdBy)
            .deleted(false)
            .version(0L)
            .build();
    }

    /**
     * Update entity from request DTO
     */
    public void updateEntity(User user, UpdateUserRequest request, String updatedBy) {
        if (request.getFirstName() != null) {
            user.setFirstName(request.getFirstName());
        }
        if (request.getLastName() != null) {
            user.setLastName(request.getLastName());
        }
        if (request.getDisplayName() != null) {
            user.setDisplayName(request.getDisplayName());
        }
        if (request.getRole() != null) {
            user.setRole(request.getRole());
        }
        if (request.getPreferences() != null) {
            user.setPreferences(request.getPreferences());
        }
        if (request.getSettings() != null) {
            user.setSettings(request.getSettings());
        }

        user.setUpdatedBy(updatedBy);
        user.setVersion(user.getVersion() + 1);
    }

    private ContactInfo fetchContactInfo(UUID userId) {
        try {
            ApiResponse<List<ContactDto>> response =
                contactClient.getContactsByOwner(userId.toString());

            if (response == null || response.getData() == null) {
                return ContactInfo.empty();
            }

            List<ContactDto> contacts = response.getData();

            String email = contacts.stream()
                .filter(c -> "EMAIL".equals(c.getContactType()))
                .filter(ContactDto::isPrimary)
                .findFirst()
                .map(ContactDto::getContactValue)
                .orElse(null);

            String phone = contacts.stream()
                .filter(c -> "PHONE".equals(c.getContactType()))
                .filter(ContactDto::isPrimary)
                .findFirst()
                .map(ContactDto::getContactValue)
                .orElse(null);

            return new ContactInfo(email, phone);
        } catch (Exception e) {
            log.warn("Failed to fetch contacts for user {}: {}", userId, e.getMessage());
            return ContactInfo.empty();
        }
    }

    @Value
    @AllArgsConstructor
    public static class ContactInfo {
        String email;
        String phone;

        public static ContactInfo empty() {
            return new ContactInfo(null, null);
        }
    }
}
```

**Faydalar:**

- ‚úÖ Mapping logic tek yerde
- ‚úÖ Reusable
- ‚úÖ Test edilebilir
- ‚úÖ Service'den baƒüƒ±msƒ±z

---

## 4Ô∏è‚É£ Repository Layer

### ‚ùå √ñNCE

```java
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {

    List<User> findByTenantId(UUID tenantId);

    long countActiveUsersByTenant(UUID tenantId);
}

// Service'de tekrar eden logic
User user = userRepository.findById(userId)
    .filter(u -> !u.isDeleted())
    .filter(u -> u.getTenantId().equals(tenantId))
    .orElseThrow(() -> new RuntimeException("User not found"));
```

### ‚úÖ SONRA

```java
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {

    /**
     * Finds active user by ID and tenant
     */
    @Query("SELECT u FROM User u WHERE u.id = :id AND u.tenantId = :tenantId AND u.deleted = false")
    Optional<User> findActiveByIdAndTenantId(
        @Param("id") UUID id,
        @Param("tenantId") UUID tenantId);

    /**
     * Finds all active users by tenant
     */
    @Query("SELECT u FROM User u WHERE u.tenantId = :tenantId AND u.deleted = false ORDER BY u.createdAt DESC")
    List<User> findAllActiveByTenantId(@Param("tenantId") UUID tenantId);

    /**
     * Counts active users by tenant
     */
    @Query("SELECT COUNT(u) FROM User u WHERE u.tenantId = :tenantId AND u.deleted = false AND u.status = 'ACTIVE'")
    long countActiveUsersByTenant(@Param("tenantId") UUID tenantId);

    /**
     * Checks if active user exists
     */
    @Query("SELECT CASE WHEN COUNT(u) > 0 THEN true ELSE false END FROM User u WHERE u.id = :id AND u.tenantId = :tenantId AND u.deleted = false")
    boolean existsActiveByIdAndTenantId(
        @Param("id") UUID id,
        @Param("tenantId") UUID tenantId);

    /**
     * Finds by tenant ID (old method - keep for backward compatibility)
     */
    @Deprecated
    List<User> findByTenantId(UUID tenantId);
}

// Service'de kullanƒ±m
User user = userRepository.findActiveByIdAndTenantId(userId, tenantId)
    .orElseThrow(() -> new UserNotFoundException(userId));
```

**ƒ∞yile≈ütirmeler:**

- ‚úÖ Common filters repository'de
- ‚úÖ Kod tekrarƒ± yok
- ‚úÖ Query optimization
- ‚úÖ Clear method names

---

## 5Ô∏è‚É£ Exception Handling

### ‚ùå √ñNCE

```java
// Generic RuntimeException
.orElseThrow(() -> new RuntimeException("User not found: " + userId));
.orElseThrow(() -> new RuntimeException("Company not found"));

// Controller'da try-catch
try {
    LoginResponse response = authService.login(request);
    return ResponseEntity.ok(ApiResponse.success(response, "Login successful"));
} catch (Exception e) {
    log.error("Login failed: {}", e.getMessage());
    return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
        .body(ApiResponse.error(e.getMessage(), "LOGIN_FAILED"));
}
```

### ‚úÖ SONRA

```java
// Domain-specific exceptions
.orElseThrow(() -> new UserNotFoundException(userId));
.orElseThrow(() -> new CompanyNotFoundException(companyId));

// Controller - no try-catch (handled by @RestControllerAdvice)
@PostMapping("/login")
public ResponseEntity<ApiResponse<LoginResponse>> login(@Valid @RequestBody LoginRequest request) {
    log.info("Login attempt for contact: {}", request.getContactValue());
    LoginResponse response = authService.login(request);
    return ResponseEntity.ok(ApiResponse.success(response, "Login successful"));
}

// Global exception handler
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ApiResponse<Void>> handleUserNotFound(UserNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(ApiResponse.error(ex.getMessage(), ex.getErrorCode()));
    }

    @ExceptionHandler(InvalidPasswordException.class)
    public ResponseEntity<ApiResponse<Void>> handleInvalidPassword(InvalidPasswordException ex) {
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
            .body(ApiResponse.error(ex.getMessage(), ex.getErrorCode()));
    }
}
```

**ƒ∞yile≈ütirmeler:**

- ‚úÖ Domain-specific exceptions
- ‚úÖ Centralized error handling
- ‚úÖ Consistent error responses
- ‚úÖ Clean controller code

---

## 6Ô∏è‚É£ Company Service (CQRS Simplification)

### ‚ùå √ñNCE (Over-engineering)

```java
@Service
@RequiredArgsConstructor
public class CompanyService {

    // 7 Command Handlers
    private final CreateCompanyCommandHandler createHandler;
    private final UpdateCompanyCommandHandler updateHandler;
    private final DeleteCompanyCommandHandler deleteHandler;
    private final UpdateCompanySettingsCommandHandler settingsHandler;
    private final UpdateSubscriptionCommandHandler subscriptionHandler;
    private final ActivateCompanyCommandHandler activateHandler;
    private final DeactivateCompanyCommandHandler deactivateHandler;

    // 4 Query Handlers
    private final GetCompanyQueryHandler getHandler;
    private final ListCompaniesQueryHandler listHandler;
    private final SearchCompaniesQueryHandler searchHandler;
    private final GetCompaniesByStatusQueryHandler statusHandler;

    public UUID createCompany(CreateCompanyRequest request, UUID tenantId, String createdBy) {
        // Request ‚Üí Command conversion
        CreateCompanyCommand command = CreateCompanyCommand.builder()
            .tenantId(tenantId)
            .name(request.getName())
            .legalName(request.getLegalName())
            // 10+ field mapping
            .build();

        // Delegate to handler
        return createHandler.handle(command);
    }
}

// Separate handler file (50+ lines each)
@Component
public class CreateCompanyCommandHandler {
    public UUID handle(CreateCompanyCommand command) {
        // Validation
        // Entity creation
        // Save
        // Event publish
    }
}
```

**Sorunlar:**

- 11 ayrƒ± handler sƒ±nƒ±fƒ±
- Request ‚Üí Command ‚Üí Handler ‚Üí Entity d√∂n√º≈ü√ºm√º
- Basit CRUD i√ßin gereksiz abstraction
- 269 satƒ±r + 11 handler file

### ‚úÖ SONRA (Simple & Clean)

```java
@Service
@RequiredArgsConstructor
@Transactional
public class CompanyService {

    private final CompanyRepository repository;
    private final CompanyMapper mapper;
    private final CompanyEventPublisher eventPublisher;

    public UUID createCompany(CreateCompanyRequest request, UUID tenantId, String createdBy) {
        validateCompanyDoesNotExist(request.getName(), tenantId);

        Company company = mapper.toEntity(request, tenantId, createdBy);
        company = repository.save(company);

        eventPublisher.publishCompanyCreated(company);
        return company.getId();
    }

    @Transactional(readOnly = true)
    public CompanyResponse getCompany(UUID companyId, UUID tenantId) {
        Company company = repository.findActiveByIdAndTenantId(companyId, tenantId)
            .orElseThrow(() -> new CompanyNotFoundException(companyId));
        return mapper.toResponse(company);
    }

    public void updateCompany(UUID companyId, UpdateCompanyRequest request,
                             UUID tenantId, String updatedBy) {
        Company company = repository.findActiveByIdAndTenantId(companyId, tenantId)
            .orElseThrow(() -> new CompanyNotFoundException(companyId));

        mapper.updateEntity(company, request, updatedBy);
        repository.save(company);

        eventPublisher.publishCompanyUpdated(company);
    }

    private void validateCompanyDoesNotExist(String name, UUID tenantId) {
        if (repository.existsByNameAndTenantId(name, tenantId)) {
            throw new CompanyAlreadyExistsException(name);
        }
    }
}
```

**ƒ∞yile≈ütirmeler:**

- ‚úÖ 150 satƒ±r (11 handler kaldƒ±rƒ±ldƒ±)
- ‚úÖ KISS prensibi
- ‚úÖ Basit CRUD i√ßin basit kod
- ‚úÖ Maintenance kolay

---

## üìä √ñzet Kar≈üƒ±la≈ütƒ±rma

| Bile≈üen                | √ñnce                   | Sonra          | ƒ∞yile≈ütirme      |
| ---------------------- | ---------------------- | -------------- | ---------------- |
| **UserService**        | 370 satƒ±r              | 150 satƒ±r      | -59%             |
| **UserController**     | 181 satƒ±r              | 120 satƒ±r      | -34%             |
| **CompanyService**     | 269 satƒ±r + 11 handler | 150 satƒ±r      | -71%             |
| **Mapping Logic**      | Service i√ßinde         | Ayrƒ± Mapper    | +100% Separation |
| **Repository Queries** | Service'de filter      | Repository'de  | +100% Reuse      |
| **Exception Handling** | Try-catch her yerde    | Global handler | -80% Kod         |
| **Security Context**   | Her method'da          | Injection      | -90% Tekrar      |

---

## üéØ Sonu√ß

**√ñnce:**

- üî¥ 370 satƒ±rlƒ±k service sƒ±nƒ±flarƒ±
- üî¥ %35 kod tekrarƒ±
- üî¥ Mixed responsibilities
- üî¥ Zor test edilebilir
- üî¥ Over-engineering

**Sonra:**

- ‚úÖ 150 satƒ±rlƒ±k service sƒ±nƒ±flarƒ±
- ‚úÖ %10 kod tekrarƒ±
- ‚úÖ Single responsibility
- ‚úÖ Kolay test edilebilir
- ‚úÖ KISS prensibi

**Toplam ƒ∞yile≈ütirme:** %60 daha temiz kod!
