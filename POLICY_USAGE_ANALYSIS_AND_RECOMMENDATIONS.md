# üîê Policy Usage Analysis & Recommendations

**Tarih:** 2025-10-10  
**Ama√ß:** Mevcut policy kullanƒ±mƒ±nƒ± analiz et, eksiklikleri tespit et, √∂neriler sun  
**Analiz Eden:** AI Assistant + Kod ƒ∞nceleme  
**Status:** ‚úÖ Analysis Complete

---

## üìä MEVCUT DURUM ANALƒ∞Zƒ∞

### Service Bazƒ±nda Policy Kullanƒ±mƒ±

| Service             | Policy Field'larƒ±                                  | Kullanƒ±m Durumu                  | Deƒüerlendirme     |
| ------------------- | -------------------------------------------------- | -------------------------------- | ----------------- |
| **User-Service**    | ‚úÖ userContext                                     | Entity'de var, ama kullanƒ±lmƒ±yor | ‚ö†Ô∏è Eksik kullanƒ±m |
| **Company-Service** | ‚úÖ businessType, parentCompanyId, relationshipType | Entity'de var VE kullanƒ±lƒ±yor    | ‚úÖ Tam kullanƒ±m   |
| **Contact-Service** | ‚ùå YOK                                             | Policy field yok                 | ‚úÖ Gerekmeyebilir |
| **API Gateway**     | ‚úÖ PolicyEngine                                    | PEP olarak kullanƒ±lƒ±yor          | ‚úÖ Tam kullanƒ±m   |

---

## üîç DETAYLI ANALƒ∞Z

### 1Ô∏è‚É£ User-Service Policy Durumu

#### Mevcut Kod (User.java)

```java
@Entity
public class User extends BaseEntity {
    // ‚úÖ Policy field VAR
    @Column(name = "user_context", nullable = false)
    private UserContext userContext = UserContext.INTERNAL;

    // ‚úÖ ƒ∞li≈üki field'larƒ± var
    @Column(name = "company_id")
    private UUID companyId;

    @Column(name = "department_id")
    private UUID departmentId;

    @Column(name = "role")
    private String role;  // ADMIN, USER, MANAGER, etc.
}
```

#### Policy Kullanƒ±mƒ±

**Database:** ‚úÖ Field var (satƒ±r 91-93)  
**Service Layer:** ‚ùå Policy check YOK  
**Controller:** ‚ùå Policy enforcement YOK  
**PolicyEngine Integration:** ‚ùå YOK

#### Eksik Kullanƒ±m

```java
// ‚ùå MEVCUT: UserService policy kullanmƒ±yor
@Service
public class UserService {
    public UUID createUser(CreateUserRequest request, UUID tenantId, String createdBy) {
        User user = userMapper.fromCreateRequest(request, tenantId, createdBy);
        user = userRepository.save(user);
        // Policy check YOK!
        return user.getId();
    }
}

// ‚úÖ OLMALIAYDI: Policy check eklenebilir
@Service
public class UserService {
    private final PolicyEngine policyEngine;  // EKLE!

    public UUID createUser(CreateUserRequest request, UUID tenantId, String createdBy) {
        // Policy check - sadece INTERNAL company user create edebilir
        PolicyContext ctx = PolicyContext.builder()
            .companyType(getCompanyType(tenantId))
            .operation(OperationType.WRITE)
            .endpoint("/api/v1/users")
            .build();

        PolicyDecision decision = policyEngine.evaluate(ctx);
        if (!decision.isAllowed()) {
            throw new ForbiddenException(decision.getReason());
        }

        User user = userMapper.fromCreateRequest(request, tenantId, createdBy);
        user = userRepository.save(user);
        return user.getId();
    }
}
```

#### Deƒüerlendirme: ‚ö†Ô∏è **EKSIK KULLANIM**

**Sorun:**

- UserContext field var ama kullanƒ±lmƒ±yor
- Policy enforcement yok
- Business rule'lar eksik

**√ñneriler:**

1. **Option A: Policy Enforcement Ekle (√ñnerilen)** ‚úÖ

   ```
   - UserService'e PolicyEngine inject et
   - CREATE/UPDATE/DELETE operasyonlarƒ±nda policy check
   - INTERNAL company user create edebilir
   - CUSTOMER/SUPPLIER company user create EDEMEZ
   ```

2. **Option B: Sadece Gateway'de Kontrol Et** ‚ö†Ô∏è

   ```
   - Gateway PEP zaten var
   - Service'de tekrar check gerekmeyebilir
   - Defense in depth i√ßin ideal deƒüil
   ```

3. **Option C: UserContext Field'ƒ±nƒ± Kaldƒ±r** ‚ùå
   ```
   - Kullanƒ±lmƒ±yorsa kaldƒ±r (YAGNI)
   - Ancak gelecekte lazƒ±m olabilir
   - √ñnerilmez
   ```

**TAVSƒ∞YE:** **Option A** - Policy enforcement ekle (defense in depth)

---

### 2Ô∏è‚É£ Company-Service Policy Durumu

#### Mevcut Kod (Company.java)

```java
@Entity
public class Company extends BaseEntity {
    // ‚úÖ Policy field'larƒ± TAM
    @Enumerated(EnumType.STRING)
    @Column(name = "business_type", nullable = false)
    private CompanyType businessType = CompanyType.INTERNAL;

    @Column(name = "parent_company_id")
    private UUID parentCompanyId;

    @Column(name = "relationship_type")
    private String relationshipType;
}
```

#### Policy Kullanƒ±mƒ±

**Database:** ‚úÖ Field'lar var  
**Service Layer:** ‚úÖ Field'lar set ediliyor  
**Controller:** ‚úÖ CreateCompanyRequest policy field'larƒ± i√ßeriyor  
**PolicyEngine Integration:** ‚ö†Ô∏è Service'de direkt kullanƒ±lmƒ±yor

#### Mevcut Kullanƒ±m

```java
// ‚úÖ MEVCUT: Company creation policy field'larƒ± set ediyor
@Component
public class CompanyMapper {
    public Company fromCreateRequest(CreateCompanyRequest request, UUID tenantId, String createdBy) {
        Company company = Company.builder()
                .businessType(CompanyType.valueOf(request.getBusinessType()))
                .parentCompanyId(request.getParentCompanyId())
                .relationshipType(request.getRelationshipType())
                .build();
        return company;
    }
}
```

#### Eksik Kullanƒ±m

```java
// ‚ö†Ô∏è EKSIK: Policy validation yok
// CUSTOMER company ba≈üka CUSTOMER yaratabilir mi? ‚Üí Kontrol YOK!
// SUPPLIER company CUSTOMER yaratabilir mi? ‚Üí Kontrol YOK!
```

#### Deƒüerlendirme: ‚úÖ **KISMI KULLANIM - ƒ∞Yƒ∞LE≈ûTƒ∞Rƒ∞LEBƒ∞Lƒ∞R**

**G√º√ßl√º Y√∂nler:**

- Policy field'larƒ± entity'de var
- Creation sƒ±rasƒ±nda set ediliyor
- Company type hierarchy var

**Eksik Y√∂nler:**

- Policy validation yok
- PolicyEngine kullanƒ±lmƒ±yor
- Business rule enforcement eksik

**√ñneriler:**

1. **Policy Validation Ekle** ‚úÖ

   ```java
   // Business rule: Sadece INTERNAL company diƒüerlerini create edebilir
   if (request.getBusinessType() != CompanyType.INTERNAL) {
       // Kendi company type'ƒ±nƒ± kontrol et
       Company creatorCompany = getCompany(tenantId);
       if (creatorCompany.getBusinessType() != CompanyType.INTERNAL) {
           throw new ForbiddenException("Only INTERNAL companies can create other companies");
       }
   }
   ```

2. **PolicyEngine Integration** (Opsiyonel)
   ```java
   // Defense in depth - Gateway'den sonra service'de de check
   PolicyDecision decision = policyEngine.evaluate(context);
   ```

---

### 3Ô∏è‚É£ Contact-Service Policy Durumu

#### Mevcut Kod (Contact.java)

```java
@Entity
public class Contact extends BaseEntity {
    private UUID ownerId;        // User veya Company ID
    private OwnerType ownerType; // USER, COMPANY
    private ContactType contactType;  // EMAIL, PHONE, ADDRESS
    private boolean isVerified;
    private boolean isPrimary;

    // ‚ùå Policy field'larƒ± YOK
    // ‚ùå Company type bilgisi YOK
    // ‚ùå User context bilgisi YOK
}
```

#### Policy Kullanƒ±mƒ±

**Database:** ‚ùå Policy field yok  
**Service Layer:** ‚ùå Policy check yok  
**PolicyEngine Integration:** ‚ùå YOK

#### Deƒüerlendirme: ‚úÖ **DOƒûRU - GEREKMEZ**

**Neden Policy Gerekmez:**

1. **Basit Domain**

   ```
   Contact = Email, Phone, Address
   Business logic basit: verify, makePrimary
   Authorization kompleks deƒüil
   ```

2. **Owner-based Authorization Yeterli**

   ```java
   // Mevcut y√∂ntem yeterli:
   if (!contact.getOwnerId().equals(currentUserId)) {
       throw new UnauthorizedException();
   }
   ```

3. **Cross-company Access Gereksiz**
   ```
   Contact her zaman owner'ƒ±na aittir
   Cross-company contact access business requirement deƒüil
   ```

**TAVSƒ∞YE:** ‚úÖ **Contact-Service'de policy GEREKMEZ**

---

## üéØ POLICY YAPISI NE ƒ∞≈û YAPIYOR?

### Policy Authorization Sistemi - Detaylƒ± A√ßƒ±klama

#### Ama√ß

**Sorun:** Basit rol-based authorization yeterli deƒüil!

**√ñrnek Senaryolar:**

```
Senaryo 1: CUSTOMER company'nin ADMIN'i ne yapabilir?
  ‚ùå Basit rol: ADMIN = her ≈üeyi yapabilir (YANLI≈û!)
  ‚úÖ Policy: CUSTOMER company ba≈üka company yaratamaz (DOƒûRU!)

Senaryo 2: SUPPLIER company'nin MANAGER'ƒ± kendi user'larƒ±nƒ± g√∂rebilir mi?
  ‚ùå Basit rol: MANAGER = sadece kendi department (YANLI≈û!)
  ‚úÖ Policy: SUPPLIER sadece SELF scope, ba≈ükasƒ±nƒ± g√∂remez (DOƒûRU!)

Senaryo 3: ƒ∞√ß ADMIN advanced settings'e eri≈üebilir mi?
  ‚ùå Basit rol: ADMIN = t√ºm settings (Bazen YANLI≈û!)
  ‚úÖ Policy: Specific grant gerekir, explicit ALLOW (DOƒûRU!)
```

#### Policy Engine Flow (6 Adƒ±m)

```
1. Company Type Guardrails
   ‚îî‚îÄ> CUSTOMER/SUPPLIER belirli endpoint'lere ERƒ∞≈ûEMEZ
   ‚îî‚îÄ> First DENY wins - guardrail ihlali ‚Üí DENY

2. Platform Policy
   ‚îî‚îÄ> policy_registry'den endpoint + operation + role check
   ‚îî‚îÄ> DENY varsa ‚Üí DENY

3. User DENY Grants
   ‚îî‚îÄ> user_permissions'dan explicit DENY check
   ‚îî‚îÄ> Varsa ‚Üí DENY

4. Role Default Access
   ‚îî‚îÄ> ADMIN, MANAGER, USER default permission'larƒ±
   ‚îî‚îÄ> Yoksa devam

5. User ALLOW Grants
   ‚îî‚îÄ> user_permissions'dan explicit ALLOW check
   ‚îî‚îÄ> Varsa ‚Üí ALLOW (role override)

6. Data Scope Validation
   ‚îî‚îÄ> SELF, COMPANY, CROSS_COMPANY, GLOBAL
   ‚îî‚îÄ> ƒ∞hlal varsa ‚Üí DENY

‚Üí T√ºm checkler passed ‚Üí ALLOW
```

#### √ñrnek 1: CUSTOMER Company User Create Edemez

```java
// Request: CUSTOMER company new user create etmek istiyor
POST /api/v1/users

// Policy Check
PolicyContext ctx = PolicyContext.builder()
    .companyType(CompanyType.CUSTOMER)  // ‚Üê CUSTOMER!
    .operation(OperationType.WRITE)
    .endpoint("/api/v1/users")
    .build();

PolicyDecision decision = policyEngine.evaluate(ctx);

// Step 1: Company Type Guardrail
CompanyTypeGuard.check(ctx)
  ‚Üí CUSTOMER company USER create edemez
  ‚Üí DENY: "External companies cannot create users"

// Result: DENY ‚ùå
```

#### √ñrnek 2: INTERNAL Company Admin Advanced Settings

```java
// Request: INTERNAL admin /advanced-settings eri≈ümek istiyor
GET /api/v1/companies/{id}/advanced-settings

// Policy Check
PolicyContext ctx = PolicyContext.builder()
    .companyType(CompanyType.INTERNAL)  // ‚Üê INTERNAL
    .operation(OperationType.READ)
    .endpoint("/api/v1/companies/*/advanced-settings")
    .roles(List.of("ADMIN"))
    .build();

// Step 1: Guardrail - PASS (INTERNAL OK)
// Step 2: Platform Policy
PolicyRegistry policy = findPolicy("/advanced-settings", "READ")
  ‚Üí allowedRoles: ["SUPER_ADMIN"]  // ‚Üê ADMIN yok!
  ‚Üí DENY: "Requires SUPER_ADMIN role"

// Step 5: User ALLOW Grant Check
UserPermission grant = findUserGrant(userId, endpoint)
  ‚Üí Explicit ALLOW var mƒ±?
  ‚Üí Varsa: ALLOW (role override)
  ‚Üí Yoksa: DENY

// Result: DENY (grant yoksa) ‚ùå
```

---

## üéØ POLICY GEREKLƒ∞ Mƒ∞? - SERVƒ∞S BAZINDA ANALƒ∞Z

### User-Service'de Policy Gerekli Mi?

#### ‚úÖ **EVET - GEREKLƒ∞!**

**Neden Gerekli:**

1. **Cross-Company User Management**

   ```
   Senaryo: CUSTOMER company SUPPLIER company user'ƒ±nƒ± g√∂rebilir mi?
   Cevap: HAYIR - Policy ile engellenmeli
   ```

2. **User Creation Restriction**

   ```
   Senaryo: CUSTOMER company new user create edebilir mi?
   Cevap: HAYIR - Sadece INTERNAL create edebilir
   ```

3. **Role Assignment Control**
   ```
   Senaryo: CUSTOMER company SUPER_ADMIN role verebilir mi?
   Cevap: HAYIR - Sadece INTERNAL verebilir
   ```

#### Eksik Kullanƒ±m

**Mevcut:**

```java
// ‚ùå EKSIK: Policy check yok
@Service
public class UserService {
    public UUID createUser(CreateUserRequest request, UUID tenantId, String createdBy) {
        User user = userMapper.fromCreateRequest(request, tenantId, createdBy);
        user = userRepository.save(user);
        return user.getId();
    }
}
```

**Olmalƒ±:**

```java
// ‚úÖ OLMALI: Policy check ekle
@Service
public class UserService {
    private final PolicyEngine policyEngine;
    private final CompanyRepository companyRepository;  // Company type i√ßin

    public UUID createUser(CreateUserRequest request, UUID tenantId, String createdBy) {
        // 1. Company type al
        Company company = companyRepository.findByTenantId(tenantId);

        // 2. Policy check
        PolicyContext ctx = PolicyContext.builder()
                .userId(createdBy)
                .companyId(company.getId())
                .companyType(company.getBusinessType())
                .endpoint("/api/v1/users")
                .operation(OperationType.WRITE)
                .scope(DataScope.COMPANY)
                .roles(getCurrentUserRoles())
                .build();

        PolicyDecision decision = policyEngine.evaluate(ctx);
        if (!decision.isAllowed()) {
            throw new ForbiddenException(decision.getReason());
        }

        // 3. Business logic
        User user = userMapper.fromCreateRequest(request, tenantId, createdBy);
        user = userRepository.save(user);

        return user.getId();
    }
}
```

#### √ñnerilen Business Rules

| Operasyon                    | INTERNAL | CUSTOMER   | SUPPLIER   | Rule                                            |
| ---------------------------- | -------- | ---------- | ---------- | ----------------------------------------------- |
| **Create User**              | ‚úÖ ALLOW | ‚ùå DENY    | ‚ùå DENY    | Sadece INTERNAL user yaratabilir                |
| **View Own Users**           | ‚úÖ ALLOW | ‚úÖ ALLOW   | ‚úÖ ALLOW   | Herkes kendi user'larƒ±nƒ± g√∂rebilir              |
| **View Other Company Users** | ‚úÖ ALLOW | ‚ùå DENY    | ‚ùå DENY    | Sadece INTERNAL ba≈ükalarƒ±nƒ± g√∂rebilir           |
| **Update User Role**         | ‚úÖ ALLOW | ‚ö†Ô∏è LIMITED | ‚ö†Ô∏è LIMITED | CUSTOMER/SUPPLIER sadece USER/MANAGER verebilir |
| **Delete User**              | ‚úÖ ALLOW | ‚ö†Ô∏è LIMITED | ‚ö†Ô∏è LIMITED | Sadece kendi company user'ƒ± silebilir           |

---

### Company-Service'de Policy Kullanƒ±mƒ±

#### ‚úÖ **TAM KULLANIM - AMA ƒ∞Yƒ∞LE≈ûTƒ∞Rƒ∞LEBƒ∞Lƒ∞R**

**Mevcut Kullanƒ±m:**

```java
// ‚úÖ Field'lar var ve set ediliyor
@Component
public class CompanyMapper {
    public Company fromCreateRequest(CreateCompanyRequest request, UUID tenantId, String createdBy) {
        Company company = Company.builder()
                .businessType(CompanyType.valueOf(request.getBusinessType()))
                .parentCompanyId(request.getParentCompanyId())
                .relationshipType(request.getRelationshipType())
                .build();
        return company;
    }
}
```

**Eksik:**

```java
// ‚ö†Ô∏è EKSIK: Policy validation yok
// Business rule check edilmiyor:
// - CUSTOMER ba≈üka CUSTOMER yaratabilir mi? ‚Üí Kontrol YOK
// - SUPPLIER INTERNAL yaratabilir mi? ‚Üí Kontrol YOK
```

**Olmalƒ±:**

```java
@Service
public class CompanyService {
    private final PolicyEngine policyEngine;

    public UUID createCompany(CreateCompanyRequest request, UUID tenantId, String createdBy) {
        // 1. Creator company type al
        Company creatorCompany = companyRepository.findByTenantId(tenantId);

        // 2. Business rule: Sadece INTERNAL ba≈üka company yaratabilir
        if (creatorCompany.getBusinessType() != CompanyType.INTERNAL) {
            throw new ForbiddenException("Only INTERNAL companies can create other companies");
        }

        // 3. Policy check (opsiyonel - Gateway'de de var)
        PolicyContext ctx = PolicyContext.builder()
                .companyType(creatorCompany.getBusinessType())
                .endpoint("/api/v1/companies")
                .operation(OperationType.WRITE)
                .build();

        PolicyDecision decision = policyEngine.evaluate(ctx);
        if (!decision.isAllowed()) {
            throw new ForbiddenException(decision.getReason());
        }

        // 4. Business logic
        Company company = companyMapper.fromCreateRequest(request, tenantId, createdBy);
        company = companyRepository.save(company);

        return company.getId();
    }
}
```

#### √ñnerilen Business Rules

| Operasyon                | INTERNAL | CUSTOMER   | SUPPLIER   | Rule                                      |
| ------------------------ | -------- | ---------- | ---------- | ----------------------------------------- |
| **Create Company**       | ‚úÖ ALLOW | ‚ùå DENY    | ‚ùå DENY    | Sadece INTERNAL create edebilir           |
| **View Own Company**     | ‚úÖ ALLOW | ‚úÖ ALLOW   | ‚úÖ ALLOW   | Herkes kendi company'sini g√∂rebilir       |
| **View Other Companies** | ‚úÖ ALLOW | ‚ùå DENY    | ‚ùå DENY    | Sadece INTERNAL ba≈ükalarƒ±nƒ± g√∂rebilir     |
| **Update Company**       | ‚úÖ ALLOW | ‚ö†Ô∏è LIMITED | ‚ö†Ô∏è LIMITED | Sadece kendi company'sini update edebilir |
| **Delete Company**       | ‚úÖ ALLOW | ‚ùå DENY    | ‚ùå DENY    | Sadece INTERNAL silebilir                 |

---

### Contact-Service'de Policy Gerekli Mi?

#### ‚ùå **HAYIR - GEREKMEZ**

**Neden Gerekmez:**

1. **Basit Domain**

   ```
   Contact = Email, Phone, Address bilgisi
   Business logic basit: create, verify, delete
   Complex authorization gerekmez
   ```

2. **Owner-based Authorization Yeterli**

   ```java
   // Mevcut y√∂ntem yeterli:
   public Contact getContact(UUID contactId, UUID currentUserId) {
       Contact contact = contactRepository.findById(contactId);

       // Simple check: Owner mƒ±?
       if (!contact.getOwnerId().equals(currentUserId)) {
           throw new UnauthorizedException("Not your contact");
       }

       return contact;
   }
   ```

3. **Cross-Company Contact Gereksiz**

   ```
   Bir user ba≈üka company'nin contact'ƒ±na neden eri≈üsin?
   Business requirement yok
   Policy gereksiz complexity ekler
   ```

4. **Gateway Authorization Yeterli**

   ```
   Gateway zaten:
   - JWT validation yapƒ±yor
   - Tenant isolation yapƒ±yor
   - Rate limiting yapƒ±yor

   Contact endpoints basit CRUD
   Extra policy check gereksiz
   ```

**TAVSƒ∞YE:** Contact-Service'de policy EKLEME! ‚úÖ

---

## üìã POLICY KULLANIM KAR≈ûILA≈ûTIRMASI

### Mevcut Durum vs. Olmasƒ± Gereken

| Service             | Mevcut                            | Olmasƒ± Gereken        | Gap      |
| ------------------- | --------------------------------- | --------------------- | -------- |
| **API Gateway**     | ‚úÖ PolicyEngine (PEP)             | ‚úÖ PolicyEngine (PEP) | ‚úÖ Tam   |
| **User-Service**    | ‚ö†Ô∏è Field var, kullanƒ±lmƒ±yor       | ‚úÖ Policy enforcement | ‚ö†Ô∏è Eksik |
| **Company-Service** | ‚ö†Ô∏è Field var, kƒ±smen kullanƒ±lƒ±yor | ‚úÖ Policy validation  | ‚ö†Ô∏è Eksik |
| **Contact-Service** | ‚ùå YOK                            | ‚ùå Gerekmez           | ‚úÖ Doƒüru |

---

## üöÄ √ñNERƒ∞LER VE AKSIYON PLANI

### Kƒ±sa Vadeli (1 hafta)

#### 1. User-Service Policy Integration

**√ñncelik:** üî¥ Y√úKSEK

**Yapƒ±lacaklar:**

```java
// A. UserService'e PolicyEngine inject et
@Service
public class UserService {
    private final PolicyEngine policyEngine;
    private final CompanyServiceClient companyServiceClient;  // Company type i√ßin
}

// B. CREATE operasyonunda policy check
public UUID createUser(CreateUserRequest request, UUID tenantId, String createdBy) {
    // Get creator's company type
    CompanyResponse company = companyServiceClient.getCompanyByTenantId(tenantId);

    // Policy check
    PolicyContext ctx = PolicyContext.builder()
            .companyType(CompanyType.valueOf(company.getBusinessType()))
            .operation(OperationType.WRITE)
            .endpoint("/api/v1/users")
            .scope(DataScope.COMPANY)
            .build();

    PolicyDecision decision = policyEngine.evaluate(ctx);
    if (!decision.isAllowed()) {
        throw new ForbiddenException(decision.getReason());
    }

    // Business logic...
}

// C. LIST operasyonunda scope check
public List<UserResponse> listUsers(UUID tenantId, DataScope scope) {
    // Policy check
    PolicyContext ctx = PolicyContext.builder()
            .companyType(getCompanyType(tenantId))
            .operation(OperationType.READ)
            .endpoint("/api/v1/users")
            .scope(scope)  // SELF, COMPANY, CROSS_COMPANY, GLOBAL
            .build();

    PolicyDecision decision = policyEngine.evaluate(ctx);
    if (!decision.isAllowed()) {
        throw new ForbiddenException(decision.getReason());
    }

    // Scope'a g√∂re query
    return switch(scope) {
        case SELF -> getUsersByUser(userId);
        case COMPANY -> getUsersByCompany(companyId);
        case CROSS_COMPANY -> getUsersByTenant(tenantId);
        case GLOBAL -> getAllUsers();  // Only INTERNAL + SUPER_ADMIN
    };
}
```

**Efor:** 1-2 g√ºn  
**Etki:** High - Security improvement

---

#### 2. Company-Service Policy Validation

**√ñncelik:** üü° ORTA

**Yapƒ±lacaklar:**

```java
@Service
public class CompanyService {
    private final PolicyEngine policyEngine;

    public UUID createCompany(CreateCompanyRequest request, UUID tenantId, String createdBy) {
        // Business rule validation
        Company creatorCompany = companyRepository.findByTenantId(tenantId);

        if (creatorCompany.getBusinessType() != CompanyType.INTERNAL) {
            throw new ForbiddenException("Only INTERNAL companies can create other companies");
        }

        // Policy check (defense in depth)
        PolicyContext ctx = PolicyContext.builder()
                .companyType(creatorCompany.getBusinessType())
                .operation(OperationType.WRITE)
                .endpoint("/api/v1/companies")
                .build();

        PolicyDecision decision = policyEngine.evaluate(ctx);
        if (!decision.isAllowed()) {
            throw new ForbiddenException(decision.getReason());
        }

        // Business logic...
    }
}
```

**Efor:** 1 g√ºn  
**Etki:** Medium - Business rule enforcement

---

#### 3. Dok√ºmantasyon G√ºncellemesi

**√ñncelik:** üü¢ D√ú≈û√úK (ama yapƒ±lmalƒ±)

**G√ºncellenecek Dosyalar:**

1. **user-service.md**

   ```markdown
   ## Policy Integration

   - ‚úÖ UserContext field (User entity)
   - ‚ö†Ô∏è PolicyEngine integration (TODO)
   - ‚ö†Ô∏è Business rule enforcement (TODO)
   ```

2. **company-service.md**

   ```markdown
   ## Policy Integration

   - ‚úÖ CompanyType, parentCompanyId fields
   - ‚úÖ Policy data management (PolicyRegistry, UserPermission, Audit)
   - ‚ö†Ô∏è Policy validation (TODO)
   ```

3. **contact-service.md**

   ```markdown
   ## Policy Integration

   - ‚ùå NOT NEEDED - Simple owner-based authorization sufficient
   ```

**Efor:** 2 saat

---

### Orta Vadeli (1-3 ay)

#### 1. PolicyRegistry Management UI

**√ñzellik:**

```
Admin panel:
- Policy g√∂r√ºnt√ºleme
- Role assignment
- User grant management
```

**Efor:** 1 hafta

---

#### 2. Advanced Policy Rules

**√ñzellik:**

```
- Time-based policies (working hours)
- IP-based restrictions
- Request rate per user
- Dynamic policy updates
```

**Efor:** 2 hafta

---

## üìä ETKƒ∞ ANALƒ∞Zƒ∞

### User-Service Policy Eklenmezse

**Riskler:**

```
üî¥ Y√úKSEK: CUSTOMER company INTERNAL i≈ülemleri yapabilir
üî¥ Y√úKSEK: Cross-company data leak
üü° ORTA: Role escalation possible
üü¢ D√ú≈û√úK: Gateway zaten koruyor (ama defense in depth yok)
```

### Company-Service Policy Validation Eklenmezse

**Riskler:**

```
üü° ORTA: Business rule bypass possible
üü¢ D√ú≈û√úK: Gateway koruyor
üü¢ D√ú≈û√úK: ≈ûu anda kullanƒ±cƒ± sayƒ±sƒ± az
```

### Contact-Service Policy Eklenmezse

**Riskler:**

```
‚úÖ YOK - Basit authorization yeterli
```

---

## üéØ TAVSƒ∞YE - PRƒ∞ORƒ∞Tƒ∞ZE EDƒ∞LMƒ∞≈û AKSIYON PLANI

### Phase 1: Critical (1 hafta) üî¥

1. ‚úÖ **User-Service Policy Integration**
   - PolicyEngine inject et
   - CREATE user policy check
   - LIST users scope check
   - Business rule enforcement

**Etki:** Security improvement  
**Efor:** 2 g√ºn  
**Risk:** High if not done

---

### Phase 2: Important (2 hafta) üü°

1. ‚úÖ **Company-Service Policy Validation**

   - Business rule: Sadece INTERNAL create
   - Policy check defense in depth

2. ‚úÖ **Dok√ºmantasyon Update**
   - user-service.md g√ºncel kod yapƒ±sƒ±na g√∂re update
   - company-service.md g√ºncel kod yapƒ±sƒ±na g√∂re update
   - Policy kullanƒ±mƒ± dok√ºmante et

**Etki:** Business rule enforcement + Documentation  
**Efor:** 3 g√ºn  
**Risk:** Medium if not done

---

### Phase 3: Nice to Have (1-3 ay) üü¢

1. ‚úÖ **Advanced Policy Features**

   - Policy management UI
   - Time-based policies
   - IP restrictions

2. ‚úÖ **Policy-Service Creation** (opsiyonel)
   - Sadece volume artarsa
   - Mevcut yapƒ± ≈üu an yeterli

**Etki:** Feature enhancement  
**Efor:** 2-4 hafta  
**Risk:** Low if not done

---

## üìù √ñZET

### Policy Nedir?

**Fine-grained authorization sistemi:**

- ‚úÖ Rol-based (ADMIN, MANAGER, USER)
- ‚úÖ Company type-based (INTERNAL, CUSTOMER, SUPPLIER)
- ‚úÖ Scope-based (SELF, COMPANY, CROSS_COMPANY, GLOBAL)
- ‚úÖ User grant-based (Explicit ALLOW/DENY)
- ‚úÖ Audit trail (Her karar loglanƒ±yor)

### Nerede Kullanƒ±lƒ±yor?

| Katman              | Kullanƒ±m                          | Durum    |
| ------------------- | --------------------------------- | -------- |
| **API Gateway**     | ‚úÖ PEP (Policy Enforcement Point) | Tam      |
| **User-Service**    | ‚ö†Ô∏è Field var, kullanƒ±lmƒ±yor       | Eksik    |
| **Company-Service** | ‚ö†Ô∏è Field var, kƒ±smen kullanƒ±lƒ±yor | Eksik    |
| **Contact-Service** | ‚ùå YOK                            | Gerekmez |

### Nerede Gerekli?

| Service             | Gerekli Mi?  | Neden?                                      |
| ------------------- | ------------ | ------------------------------------------- |
| **User-Service**    | ‚úÖ **EVET**  | Cross-company user management, role control |
| **Company-Service** | ‚úÖ **EVET**  | Company creation control, hierarchy         |
| **Contact-Service** | ‚ùå **HAYIR** | Basit owner-based auth yeterli              |

### Aksiyon

**Critical (1 hafta):**

1. ‚úÖ User-Service policy integration
2. ‚úÖ Company-Service policy validation

**Important (2 hafta):**

1. ‚úÖ Dok√ºmantasyon update

**Nice to Have (1-3 ay):**

1. ‚úÖ Advanced features

---

**Hazƒ±rlayan:** AI Assistant  
**Tarih:** 2025-10-10  
**Sonu√ß:** Policy User ve Company'de GEREKLƒ∞, Contact'te GEREKMEZ  
**Aksiyon:** User-Service priority #1
