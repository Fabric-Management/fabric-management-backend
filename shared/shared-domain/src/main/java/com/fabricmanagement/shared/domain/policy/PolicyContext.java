package com.fabricmanagement.shared.domain.policy;

import lombok.Builder;
import lombok.Value;

import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * Policy Context (Immutable)
 * 
 * Represents the context of a policy evaluation request.
 * Contains all information needed by the PDP to make an authorization decision.
 * 
 * Key Design Decisions:
 * - @Value makes it immutable (thread-safe)
 * - All data required for policy evaluation in one place
 * - No business logic (pure data)
 * 
 * Usage:
 * <pre>
 * PolicyContext context = PolicyContext.builder()
 *     .userId(UUID.fromString("..."))
 *     .companyId(UUID.fromString("..."))
 *     .companyType(CompanyType.INTERNAL)
 *     .endpoint("/api/users/{id}")
 *     .operation(OperationType.WRITE)
 *     .scope(DataScope.COMPANY)
 *     .roles(List.of("ADMIN", "MANAGER"))
 *     .correlationId("550e8400...")
 *     .build();
 * 
 * PolicyDecision decision = policyEngine.evaluate(context);
 * </pre>
 * 
 * @author Fabric Management Team
 * @since 2.0 (Policy Authorization)
 */
@Value
@Builder(toBuilder = true)
public class PolicyContext {
    
    // =========================================================================
    // USER CONTEXT
    // =========================================================================
    
    /**
     * User ID making the request
     */
    UUID userId;
    
    /**
     * User's company ID
     * 
     * Nullable: System users (Super Admin) may not belong to a company
     */
    UUID companyId;
    
    /**
     * User's company type
     * 
     * Critical for authorization guardrails:
     * - INTERNAL: Full access
     * - CUSTOMER: Read-only
     * - SUPPLIER: Limited write (purchase orders)
     * - SUBCONTRACTOR: Limited write (production)
     * 
     * Nullable: System users may not have company type
     */
    CompanyType companyType;
    
    /**
     * User's department ID
     * 
     * Only for INTERNAL users.
     * External users don't have departments.
     * 
     * Nullable: External users or users without department
     */
    UUID departmentId;
    
    /**
     * User's roles
     * 
     * Example: ["ADMIN", "MANAGER"]
     */
    List<String> roles;
    
    /**
     * User's job title
     * 
     * Examples: "Dokumacı", "Muhasebeci", "Kalite Kontrolcü"
     * 
     * Nullable: Optional field
     */
    String jobTitle;
    
    // =========================================================================
    // REQUEST CONTEXT
    // =========================================================================
    
    /**
     * API endpoint being accessed
     * 
     * Format: "/api/users/{id}", "/api/contacts", etc.
     * 
     * Used to:
     * - Match against PolicyRegistry
     * - Determine required permissions
     * - Generate policy tags
     */
    String endpoint;
    
    /**
     * HTTP method
     * 
     * Examples: GET, POST, PUT, DELETE
     * 
     * Used to determine operation type if not explicitly provided
     */
    String httpMethod;
    
    /**
     * Operation type
     * 
     * Maps from HTTP method:
     * - GET → READ
     * - POST → WRITE
     * - PUT → WRITE
     * - DELETE → DELETE
     * 
     * Can be overridden for specific endpoints
     */
    OperationType operation;
    
    /**
     * Data scope required
     * 
     * Determines access boundary:
     * - SELF: Own data only
     * - COMPANY: Company-wide data
     * - CROSS_COMPANY: Multi-company data
     * - GLOBAL: System-wide data
     * 
     * Can be inferred from endpoint pattern or explicitly set
     */
    DataScope scope;
    
    /**
     * Resource owner ID (if accessing specific resource)
     * 
     * Example: When accessing /api/users/123, this is 123
     * 
     * Used for:
     * - SELF scope validation (is this my data?)
     * - COMPANY scope validation (is this my company's data?)
     * 
     * Nullable: List operations don't have resource owner
     */
    UUID resourceOwnerId;
    
    /**
     * Resource company ID (if accessing specific resource)
     * 
     * Example: When accessing /api/contacts/456, this is the company that owns contact 456
     * 
     * Used for:
     * - COMPANY scope validation
     * - CROSS_COMPANY access validation
     * 
     * Nullable: May not be available at PEP level
     */
    UUID resourceCompanyId;
    
    // =========================================================================
    // TRACKING & METADATA
    // =========================================================================
    
    /**
     * Correlation ID for distributed tracing
     * 
     * Generated by Gateway, flows through entire request.
     * 
     * Format: UUID string
     */
    String correlationId;
    
    /**
     * Request ID (unique per request)
     * 
     * Format: UUID string
     */
    String requestId;
    
    /**
     * Request IP address
     * 
     * Used for:
     * - Audit trail
     * - Security analysis
     * - Fraud detection
     */
    String requestIp;
    
    /**
     * JWT claims (if needed for advanced policies)
     * 
     * Nullable: Only populated if custom claims are needed
     */
    Map<String, Object> jwtClaims;
    
    /**
     * Additional metadata
     * 
     * Used for extensibility without changing the model.
     * 
     * Nullable: Optional
     */
    Map<String, Object> metadata;
    
    // =========================================================================
    // HELPER METHODS
    // =========================================================================
    
    /**
     * Check if user is from internal company
     * 
     * @return true if INTERNAL company type
     */
    public boolean isInternal() {
        return companyType != null && companyType.isInternal();
    }
    
    /**
     * Check if user is from external company
     * 
     * @return true if CUSTOMER, SUPPLIER, or SUBCONTRACTOR
     */
    public boolean isExternal() {
        return companyType != null && companyType.isExternal();
    }
    
    /**
     * Check if user has a specific role
     * 
     * @param role role name
     * @return true if user has the role
     */
    public boolean hasRole(String role) {
        return roles != null && roles.contains(role);
    }
    
    /**
     * Check if user has any of the specified roles
     * 
     * @param requiredRoles roles to check
     * @return true if user has at least one role
     */
    public boolean hasAnyRole(String... requiredRoles) {
        if (roles == null || requiredRoles == null) {
            return false;
        }
        
        for (String role : requiredRoles) {
            if (roles.contains(role)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Get effective data scope
     * Falls back to SELF if not specified
     * 
     * @return data scope (never null)
     */
    public DataScope getEffectiveScope() {
        return scope != null ? scope : DataScope.SELF;
    }
    
    /**
     * Check if accessing own data
     * 
     * @return true if resourceOwnerId matches userId
     */
    public boolean isAccessingOwnData() {
        return resourceOwnerId != null && resourceOwnerId.equals(userId);
    }
    
    /**
     * Check if accessing same company data
     * 
     * @return true if resourceCompanyId matches companyId
     */
    public boolean isAccessingSameCompanyData() {
        return resourceCompanyId != null && 
               companyId != null && 
               resourceCompanyId.equals(companyId);
    }
}

